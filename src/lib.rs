#![deny(missing_docs)]

/*!
Adds derive macros for better bounds on generated Copy, Debug, etc. implementations.

See https://smallcultfollowing.com/babysteps//blog/2022/04/12/implied-bounds-and-perfect-derive/ for a summary of the issue.
 */

mod impls;
mod perfect_macro;
mod perfect_parsing;
use crate::perfect_parsing::DerivedList;
use crate::perfect_parsing::StructOrEnum;

use proc_macro::TokenStream;
use syn::parse_macro_input;

/// In most trivial cases, acts exactly like a typical `#[derive(...)]` macro, however
/// the bounds generated by this macro are "perfect", in that they only require the minimum requirement
/// to function.
///
/// # Usage
///
/// To use this macro, simply augment a `#[derive(...)]` call with a `#[perfect_derive(...)]` call.
/// For non-supported derived types, you must still use `#[derive(...)]`. This results in code that
/// looks like the following:
///
/// ```rust
/// # use std::rc::Rc;
///
/// #[derive(thiserror::Error)]
/// #[perfect_derive(Clone, Debug)]
/// enum MyError<T> {
///     E1(Rc<T>)
/// }
/// ```
///
/// # Details
///
/// This macro supports `Eq`, `PartialEq`, `Ord`, `PartialOrd`, `Clone`, `Copy`, `Hash`, `Default`, and `Debug`.
///
/// For all bar `Default`, all data in the `struct` or `enum` must satisfy the bound. For `Default` on `enum`s,
/// only the data stored in the default enum must satisfy the `Default` trait bound.
#[proc_macro_attribute]
pub fn perfect_derive(attr: TokenStream, item: TokenStream) -> TokenStream {
    let traits = parse_macro_input!(attr as DerivedList);
    let obj = parse_macro_input!(item as StructOrEnum);

    TokenStream::from(perfect_macro::impl_traits(traits, obj))
}
